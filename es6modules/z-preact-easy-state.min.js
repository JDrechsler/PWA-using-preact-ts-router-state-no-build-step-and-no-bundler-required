import{Component}from'preact';import{observe,unobserve,raw,isObservable}from'@nx-js/observer-util';export{observable as store}from'@nx-js/observer-util';const tasks=new Set;let isStopped=!1;function add(a){isStopped?tasks.add(a):runTask(a)}function remove(a){tasks.delete(a)}function batchCallbacks(a){return function(...b){const c=b.map((a)=>'function'==typeof a?function(...b){return batch(a,this,b)}:a);return a.apply(this,c)}}function batchMethod(a,b){const c=Object.getOwnPropertyDescriptor(a,b);if(c){const d=Object.assign({},c,{set(a){const b='function'==typeof a?function(...b){return batch(a,this,b)}:a;return c.set.call(this,b)}});Object.defineProperty(a,b,d)}}function batch(a,b,c){try{return isStopped=!0,a.apply(b,c)}finally{tasks.forEach(runTask),tasks.clear(),isStopped=!1}}function runTask(a){a()}let globalObj;if('undefined'==typeof window?'undefined'!=typeof global&&(globalObj=global):globalObj=window,globalObj&&(globalObj.setTimeout=batchCallbacks(globalObj.setTimeout),globalObj.setInterval=batchCallbacks(globalObj.setInterval),globalObj.requestAnimationFrame&&(globalObj.requestAnimationFrame=batchCallbacks(globalObj.requestAnimationFrame)),globalObj.requestIdleCallback&&(globalObj.requestIdleCallback=batchCallbacks(globalObj.requestIdleCallback)),Promise.prototype.then=batchCallbacks(Promise.prototype.then),Promise.prototype.catch=batchCallbacks(Promise.prototype.catch),globalObj.WebSocket)){['onopen','onmessage','onerror','onclose'].forEach((a)=>batchMethod(globalObj.WebSocket.prototype,a))}const COMPONENT=Symbol('owner component'),DUMMY_STATE={};function view(a,{devtool:b}={}){const c=!(a.prototype&&a.prototype.render),d=c?Component:a,e=b?(c)=>b(Object.assign({Component:a},c)):void 0;class f extends d{constructor(a,b){super(a,b),this.state=this.state||{},this.state[COMPONENT]=this;const c=()=>this.setState(DUMMY_STATE);this.render=observe(this.render,{scheduler:{add:()=>add(c),delete:()=>remove(c)},debugger:e,lazy:!0})}render(){return c?a(this.props,this.context):super.render()}shouldComponentUpdate(a,b){const{props:c,state:d}=this;if(super.shouldComponentUpdate&&!super.shouldComponentUpdate(a,b))return e&&e({type:'render',renderType:'blocked'}),!1;if(d!==b)return e&&e({type:'render',renderType:'reactive'}),!0;const f=Object.keys(c),g=Object.keys(a);return!!(g.length!==f.length||g.some((b)=>c[b]!==a[b]))&&(e&&e({type:'render',renderType:'normal',props:a,oldProps:c}),!0)}static getDerivedStateFromProps(a,b){if(super.deriveStoresFromProps){const c=mapStateToStores(b);super.deriveStoresFromProps(a,...c)}return super.getDerivedStateFromProps?super.getDerivedStateFromProps(a,b):null}componentWillUnmount(){super.componentWillUnmount&&super.componentWillUnmount(),unobserve(this.render)}}if(f.displayName=a.displayName||a.name,c)for(let b of Object.keys(a))f[b]=a[b];return f}function mapStateToStores(a){const b=a[COMPONENT];return Object.keys(b).map((a)=>b[a]).filter(isObservable).map(raw)}const Cmp=function(a){const b=Component.call(this)||this;return b.store=a&&a.store||{},b};Cmp.prototype=Component.prototype;export{Cmp as Component,view,batch};